<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Node | Will Anderson]]></title>
  <link href="http://willi.am/blog/categories/node/atom.xml" rel="self"/>
  <link href="http://willi.am/"/>
  <updated>2014-06-27T19:43:35-07:00</updated>
  <id>http://willi.am/</id>
  <author>
    <name><![CDATA[Will Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thoughts On Implementing a REST Level 3 API in Node]]></title>
    <link href="http://willi.am/blog/2014/06/27/thoughts-on-implementing-a-rest-level-3-api-in-node/"/>
    <updated>2014-06-27T20:25:43-07:00</updated>
    <id>http://willi.am/blog/2014/06/27/thoughts-on-implementing-a-rest-level-3-api-in-node</id>
    <content type="html"><![CDATA[<p><strong>Warning: stream of consciousness ahead</strong></p>

<p>I&rsquo;ve been thinking about the the pieces that would be needed to implement a REST Level 3 API in Node.
I won&rsquo;t go into the details of REST Level 3 in this post, but the one of the most important concepts is that clients to the API don&rsquo;t manually build URIs for their API calls, but instead receive them as hypermedia metadata from other calls to your API.</p>

<p>Node has some great frameworks for building web servers.
I frequently use <a href="http://expressjs.com/">Express</a>, which is built on top of the <a href="http://www.senchalabs.org/connect/">Connect</a> middleware package.
Unfortunately, Express doesn&rsquo;t make it easy to add hypermedia links to API responses in a DRY way.</p>

<p>Another option is <a href="http://mcavage.me/node-restify/">node-restify</a>.
This is a popular choice for building REST APIs in Node, but again, it falls down when it comes to Hypermedia.
Here at least you can link to different API endpoints without hardcoding URLs, but there&rsquo;s still no unified way to automatically add hypermedia links to responses.</p>

<p>I&rsquo;ve tried other frameworks as well.
<a href="http://hapijs.com/">Hapi</a> comes closest, but still doesn&rsquo;t quite solve my problems with hypermedia.</p>

<p>Perhaps I&rsquo;m spoiled by the relatively elegant solutions that can be accomplished in strictly typed languages.
In C#, for example, you can keep a registry of hypermedia providers associated with different types.
When a response of a specific type is returned by a controller, the assocated hypermedia provider is invoked, and it returns a dictionary of URIs for that type.
The controller doesn&rsquo;t even have to be aware of the hypermedia provider.</p>

<p>In JavaScript, it&rsquo;s a little harder to associate types with providers, since most responses are just anonymous objects.
I do have some alternative ideas, though.
The first that comes to mind is to associate with URLs.
Most importantly, being able to say &ldquo;this route, and any route below it uses the same provider&rdquo;.
For example, consider the following routes.</p>

<p><code>
GET  /users
POST /users
GET  /users/1
GET  /users/1/edit
GET  /users/1/delete
</code></p>

<p>All of those URLs could probably use an identical (or almost identical) link provider.
Something like the following would be useful:</p>

<p>```javascript
app.hypermedia(&lsquo;/users*&rsquo;, function(route, user) {</p>

<pre><code>if ( user ) {
    return {
        "self": "/users/" + user.id,
        "edit": "/users/" + user.id + "/edit",
        "delete": "/users/" + user.id + "/delete",
    };
} else {
    return {
        "find-all": "/users",
        "create": "/users",
    };
}
</code></pre>

<p>});
```</p>

<p>I&rsquo;m not really tied to that syntax, nor is this an awesome example.
The main idea is, I want to abstract hypermedia so controllers don&rsquo;t have to worry about it.</p>

<p>The other part of this is that controllers need to send their response back through a middleware, rather than directly to the client.
In my mind, this means the best solution is to return the object.
Since Node is async, simply returning the object probably isn&rsquo;t an option in most cases.
This means the next best choice would be to return a promise from the controller.
The middleware then waits for the promise to resolve, and then handles the result.
Finally, the controller should still be able to send a response directly to the client through the res.send() function.
In that case, no hypermedia links would be provided.</p>

<p>If the controller needs to make an async call, but that call doesn&rsquo;t automatically provide a promise, a nice simplification would be to provide a function on the response object that does the same thing.
For example:</p>

<p>```javascript
app.get(&lsquo;/user/:id&rsquo;, function(req, res) {</p>

<pre><code>db.getUser(req.params.id, function(err, user) {
    res.respond(user); // res.respond could invoke hypermedia providers before response 
});
</code></pre>

<p>});
```</p>

<p>Of course you can usually use Q&rsquo;s &ldquo;denodify&rdquo; utilities, but the point here is a little flexibility. Here&rsquo;s how a Q promise might be returned. The framework would &ldquo;then&rdquo; the promise and essentially forward the result to <code>req.respond()</code>.</p>

<p>```javascript
app.get(&lsquo;/user/:id&rsquo;, function(req, res) {</p>

<pre><code>return Q.nfinvoke(db, "getUser", req.params.id);
</code></pre>

<p>});
```</p>

<p>If you want to do something with the promise result, you still can with promises.</p>

<p>```javascript
app.get(&lsquo;/user/:id&rsquo;, function(req, res) {</p>

<pre><code>return Q.nfinvoke(db, "getUser", req.params.id)
    .then(function(user) {
        var err = new Error('User not found');
        err.status = 404;
        throw err;
    });
</code></pre>

<p>});
```</p>

<p>The other great thing to note here is that we don&rsquo;t have to call <code>next(err)</code> to pass this exception to our error handler. We can throw it, and let the framework <code>.catch()</code> the exception from the promise we return.</p>

<p>The basic idea for an implementation of this is that the routing framework calls your endpoint handler, and expects it to do one of three things:</p>

<ol>
<li>Return a promise, or value (buffer, stream, string, javascript object)</li>
<li>Call <code>next()</code> to pass controll to the next handler</li>
<li>Call <code>res.send()</code>, <code>res.write()</code>, or <code>res.end()</code> like you would in Express</li>
</ol>


<p>In the first case, the framework can allow hypermedia providers, and theoretically anything, to modify the response &ldquo;on the way out the door&rdquo;.
This would be my main objective in implementing something like this.</p>

<p>I may take a stab at a prototype, but I realize that at this point, any Node web framework probably needs a name that starts with &ldquo;Yet Another&rdquo;.
Mostly, I&rsquo;m curious how well it would work for &ldquo;real&rdquo; api development.</p>

<p>Thoughts? Does something like this already exist? Hit me up on <a href="https://twitter.com/itsananderson/">my Twitter account</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ending a Stream Without Consuming Its Data]]></title>
    <link href="http://willi.am/blog/2014/06/02/ending-a-stream-without-consuming-its-data/"/>
    <updated>2014-06-02T10:28:46-07:00</updated>
    <id>http://willi.am/blog/2014/06/02/ending-a-stream-without-consuming-its-data</id>
    <content type="html"><![CDATA[<p>I ran into an issue recently while writing <a href="https://www.npmjs.org/package/placebase">a node module</a>.
My process would sometimes complete its work, but wouldn&rsquo;t end.
After a bit of debugging, I figured out what was happening.</p>

<p>I had implemented a handler for the HTTP &ldquo;location&rdquo; header.
If a response came back with that header, I would ignore that response and go fetch the new location instead.
Unfortunately, whenever I did that, the process would finish fetching the new location, and then just hang there for about a minute bofore exiting.
The reason this happened was because I wasn&rsquo;t properly handling the first response.</p>

<p>Here&rsquo;s an oversimplified explanation of what happens.
This is from my limited understanding of Node internals, so the details may be slighly off, but the overall idea is correct.</p>

<p>When you use the &ldquo;http&rdquo; module to make a request in Node, the response it gives you is a stream.
If you don&rsquo;t do anything to consume that stream&rsquo;s data, Node doesn&rsquo;t exit because there&rsquo;s still work to be done (consuming the stream).
In order to get Node to exit without something clunky like process.exit(), you just need to switch the stream to &ldquo;flowing&rdquo; mode.</p>

<p>```javascript
var http = require(&lsquo;http&rsquo;);</p>

<p>var responseHandler = function(response) {
  if (response.headers.location) {</p>

<pre><code>http.get(response.headers.location, responseHandler);
response.resume();
</code></pre>

<p>  } else {</p>

<pre><code>response.pipe(process.stdout);
</code></pre>

<p>  }
};</p>

<p>http.get(process.argv[2], responseHandler);
```</p>

<p>Notice on line 6 how I&rsquo;ve called response.resume().
This switches the response stream to &ldquo;flowing&rdquo; mode.
According to the <a href="http://nodejs.org/api/stream.html#stream_readable_resume">streams documentation</a>,
this is the way to finish a stream if you don&rsquo;t care about consuming its data.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Live Compiling ASP.NET vNext With nodemon]]></title>
    <link href="http://willi.am/blog/2014/05/14/live-compiling-aspnet-vnext-with-nodemon/"/>
    <updated>2014-05-14T12:47:24-07:00</updated>
    <id>http://willi.am/blog/2014/05/14/live-compiling-aspnet-vnext-with-nodemon</id>
    <content type="html"><![CDATA[<p>Something cool that Scott Hanselman talked about in his <a href="http://www.hanselman.com/blog/IntroducingASPNETVNext.aspx">blog post on vNext</a>
was the ability to save a C# file in Visual Studio and view the change in the browser without manually rebuilding.</p>

<p>After spending a little time messing around with the <a href="https://github.com/aspnet">newly released code</a>, I wanted similar functionality when editing C# files outside Visual Studio.
I didn&rsquo;t see a documented way to do that, but there&rsquo;s an easy workaround if you have Node installed.</p>

<p>First install the &ldquo;nodemon&rdquo; package.
This package monitors a directory for file chanages and respawns a child process whenever anything changes.</p>

<p><code>npm install -g nodemon</code></p>

<p>Now that nodemon is installed, you can use it to live-rerun your app.</p>

<p><code>nodemon --exec "K.cmd web" -e cs,json</code></p>

<p>This tells Nodemon to watch for changes to <em>.cs and </em>.json files and to restart &ldquo;K.cmd web&rdquo; when changes are detected.
Replace &ldquo;web&rdquo; with &ldquo;run&rdquo; or whatever startup command is configured for your project.</p>

<p>Note that if you&rsquo;re running in Git Bash on Windows (which I currently can&rsquo;t get working) or on a Linux/OSX machine, the &mdash;exec command will probably be either <code>K web</code> or <code>K.sh web</code>.</p>

<p><img src="/images/post-images/nodemon-k.png" alt="Live re-compiling with nodemon" /></p>

<p>This functionality is <a href="https://github.com/aspnet/Home/issues/22#issuecomment-43148021">on the way for ASP.NET vNext</a>, but for now this is a handy workaround.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Express 4 Sites On Azure]]></title>
    <link href="http://willi.am/blog/2014/05/07/running-express-4-sites-on-azure/"/>
    <updated>2014-05-07T06:57:05-07:00</updated>
    <id>http://willi.am/blog/2014/05/07/running-express-4-sites-on-azure</id>
    <content type="html"><![CDATA[<p>If you&rsquo;ve created an Express 4 app with the new scaffold utility recently, you may have noticed that it doesn&rsquo;t work in Azure. When you try to load the site, it fails with the following error:</p>

<blockquote><p>The page cannot be displayed because an internal server error has occurred.</p></blockquote>

<h2>The Diagnosis</h2>

<p>This is because of the new structure Express creates for its apps. Instead of app.js being the expected entry point, Express now specifies bin/www as the entry point for starting the server.</p>

<p>I suspect the reason for this is so that the newly scaffolded app can be consumed as a module, allowing the consumer to worry about port binding etc. Unfortunately, this causes problems for Azure.</p>

<p>When Azure starts a Node.js site, it looks for either a server.js or an app.js. As far as I can tell from my admittedly limited testing, it doesn&rsquo;t seem look at package.json for an alternate entry point. Because of this, when it includes app.js, nothing ever binds to the listening port, so the app immediately exits on startup.</p>

<h2>The Workaround</h2>

<p>Since Azure first looks for a server.js file when it starts a site, the easiest solution I&rsquo;ve found is to add a <code>server.js</code> file with the following contents.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">require</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;.</span><span class="o">/</span><span class="nx">bin</span><span class="o">/</span><span class="nx">www</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now, when Azure starts your site, it will require server.js, which will require bin/www, which will require app.js. After that somewhat convoluted redirection chain, all will again be right in the world.</p>

<p>The Azure documentation has an <a href="http://azure.microsoft.com/en-us/documentation/articles/cloud-services-nodejs-develop-deploy-express-app/">alternative workaround</a> (see steps 4 and 5 of &ldquo;Install Express&rdquo;), but I don&rsquo;t care for it.
The problem with their solution is that it duplicates the code from bin/www into server.js, which means any updates you make to bin/www will also need to be applied to server.js.
Long story short, code duplication sucks.</p>

<h2>The Solution</h2>

<p>There are a couple of things that would properly solve this problem instead of just working around it.</p>

<h3>Express Scaffold Fix</h3>

<p>There are probably a few ways Express could fix this, but the simplest I can think of would be to add a server.js that does the same thing as my workaround.
If that&rsquo;s not desirable for all sites, they could add a &ldquo;Azure compatibility&rdquo; flag that explicitly adds the sever.js workaround.</p>

<h3>Azure Fix</h3>

<p>In my oppinion, Azure should have a way to specify the entry-point in package.json rather than hardcoding to app.js and server.js.</p>

<p>The conventional <code>npm start</code> configuration is a logical place to begin, since it&rsquo;s a <a href="https://www.npmjs.org/doc/misc/npm-scripts.html">supported spec from npm</a>.</p>

<p>```
{</p>

<pre><code>"scripts": {
    "start" : "&lt;path&gt;"
}
</code></pre>

<p>}
```</p>

<p>Azure relies on iisnode, which probably can&rsquo;t consume package.json directly.
However, Azure could look at a setting in package.json during the site setup process (when it does stuff like package restore), and configure web.config, just like it does now to switch between app.js and server.js.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Whether an NPM Module Is Installed]]></title>
    <link href="http://willi.am/blog/2014/03/29/testing-whether-an-npm-module-is-installed/"/>
    <updated>2014-03-29T10:12:23-07:00</updated>
    <id>http://willi.am/blog/2014/03/29/testing-whether-an-npm-module-is-installed</id>
    <content type="html"><![CDATA[<p>Node doesn&rsquo;t have a well documented way of checking whether a module is available.
This is usually fine. You just include a package.json in your project, and expect people to run <code>npm install</code>.
This is how most popular Node frameworks work.</p>

<p>But what if you have a devDependency entry that you want to include only if it is installed?
I searched for an answer and didn&rsquo;t find anything conclusive, so I&rsquo;m documenting what I <em>did</em> find in case I forget later.</p>

<p>Buried in NPM&rsquo;s package.json documentation is <a href="https://www.npmjs.org/doc/json.html#optionalDependencies">an example</a>
for handling a package that may or may not be installed. In short, you use a try/catch. Here&rsquo;s an example:</p>

<p>```javascript
var program;</p>

<p>try {</p>

<pre><code>program = require('commander');
</code></pre>

<p>} catch (er) {</p>

<pre><code>// Any code to run if this module doesn't exist
</code></pre>

<p>}</p>

<p>if (program) {</p>

<pre><code>program.version('0.0.1') .option('-n, --name[name]', 'Your name')
     .parse(process.argv);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
